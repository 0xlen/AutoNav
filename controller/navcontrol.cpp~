#include "ros/ros.h"
//#include "ardrone_autonomy/Navdata.h" 
//#include "geometry_msgs/PoseStamped.h" 
#include "geometry_msgs/Twist.h"
#include "std_msgs/Empty.h"


class pid_control
{

public:	
	pid_control(){
            pub_ = n_.advertise<geometry_msgs::Twist>("/cmd_vel", 1); 

	    publand_ = n_.advertise<std_msgs::Empty>("ardrone/land", 1);

            sub_ = n_.subscribe("/pose", 1, &pid_control::callback, this); 
	    
	    n_.getParam("pit_ref", pit_ref);
	    n_.getParam("roll_ref", roll_ref);
  	    n_.getParam("pit_Kp", pit_Kp);
	    n_.getParam("roll_Kp", roll_Kp);
	    n_.getParam("umbral", umbral);
	    
	}

	void callback(const geometry_msgs::Twist &msg);  
        
	std::vector<float> pit_ref;
	std::vector<float> roll_ref;
	float wpx1=0.0, wpx2=0.0, wpx3=0.0, wpx4=0.0, wpx5=0.0, wpx6=0.0, wpx7=0.0;
	float wpy1=0.0, wpy2=0.0, wpy3=0.0, wpy4=0.0, wpy5=0.0, wpy6=0.0, wpy7=0.0;
	int i = 1;
	
	//int waypoint_reached = 0;
	float pit_dist, roll_dist;
	float deltaT = 1.0/30.0;	
	double pit_Kp;	
	double umbral;
	//float pit_Ki = 0.1*deltaT;
	//float pit_Kd = 0.1/deltaT;	

	double roll_Kp;	
	//float roll_Ki = 0.1*deltaT;
	//float roll_Kd = 0.1/deltaT;	

	float pit_error, roll_error, pit_lastErr, yaw_error; //roll_error,roll_lastErr;
	float pit_errSum = pit_lastErr = 0;
	
	private : 
	ros::NodeHandle n_; 
	ros::Publisher pub_; 
	ros::Subscriber sub_;
	ros::Publisher publand_;

};

void pid_control::callback(const geometry_msgs::Twist &msg){
	
	geometry_msgs::Twist msgOut; 
	std_msgs::Empty msgLand;
	
	
	//ROS_INFO_STREAM("errorh ="<<errorh);
	//pit_errSum += pit_error;			
	 //+ pit_Ki * pit_errSum + pit_Kd * (pit_error-pit_lastErr);
	//if (msgOut.linear.x > 1.0) msgOut.linear.x = 1.0;
	//msgOut.linear.x = (Kph*errorh)/referencia;
	//pit_lastErr = pit_error;
	//if(msg.pose.position.x>0.4) refChange=1;
	
	
	
	//ROS_INFO_STREAM("errorh ="<<errorh);
	//roll_errSum += roll_error;			
	//msgOut.linear.y = (roll_Kph*roll_error + roll_Kih*roll_errSum + roll_Kdh*(roll_error-roll_lastErr))/roll_reference;
	
	//if (msgOut.linear.y < -1.0) msgOut.linear.y = -1.0;
	//msgOut.linear.x = (Kph*errorh)/referencia;
	//roll_lastErr = roll_error;	

	
	
		

	//if(i==0){
		//if(pitch_ref[i] > 0 && roll_ref[i] > 0) {
			//if(msg.pose.position.x > pitch_ref[i] && msg.pose.position.y >= roll_ref[i]){
			//if(msg.linear.x > (pitch_ref[i]-0.05) && msg.linear.x < (pitch_ref[i]+0.05)){
				//if(msg.linear.y>(roll_ref[i]-0.05) && msg.linear.y<(roll_ref[i]+0.05)){
				//i++;
				//waypoint_reached++;
				//}
			//}
		//}
		/*		
		if(pitch_ref[i] < 0 && roll_ref[i] <= 0) {
			if(msg.pose.position.x < pitch_ref[i] && msg.pose.position.y <= roll_ref[i]){
			i++;
			}
		}
		*/
		//if(pitch_ref[i] > 0 && roll_ref[i] < 0) {
			//if(msg.linear.x > (pitch_ref[i]-0.05) && msg.linear.x < (pitch_ref[i]+0.05)){
				//if(msg.linear.y>(roll_ref[i]-0.05) && msg.linear.y<(roll_ref[i]+0.05)){
				//i++;
				//waypoint_reached++;
				//}
			//}
		//}
		/*
		if(pitch_ref[i] < 0 && roll_ref[i] >= 0) {
			if(msg.pose.position.x < pitch_ref[i] && msg.pose.position.y >= roll_ref[i]){
			i++;
			}
		}
		*/
		
	//}	
	

	pit_dist = fabs(pit_ref[i] - pit_ref[i-1]);
	pit_error = pit_ref[i] - msg.linear.x;
	//roll_dist = fabs(roll_ref[i] - roll_ref[i-1]);
	//roll_error = 0.0 - msg.linear.y;
	//pit_dist = sqrt(pow(pit_ref[i]-pit_ref[i-1], 2.0) + pow(roll_ref[i]-roll_ref[i-1], 2.0));
	//pit_error = sqrt(pow(msg.linear.x-pit_ref[i], 2.0) + pow(msg.linear.y-roll_ref[i], 2.0));
	msgOut.linear.x = pit_Kp * (pit_error / pit_dist);
	msgOut.linear.y = 0.0;
	msgOut.linear.z = 0.0;
	msgOut.angular.x =1.0;
	msgOut.angular.y =1.0;
	msgOut.angular.z =0.0;
	//msgOut.linear.y = roll_Kp * roll_error;

	//msgOut.linear.y = roll_Kp*roll_error;
	if(msg.linear.x > (pit_ref[i]-umbral) && msg.linear.x < (pit_ref[i]+umbral)){
		//if(msg.linear.y > (roll_ref[i]-0.05) && msg.linear.y < (roll_ref[i]+0.05)){
		if(i==1){
		wpx1=msg.linear.x;
		wpy1=msg.linear.y;
		}

		if(i==2){
		wpx2=msg.linear.x;
		wpy2=msg.linear.y;
		}

		if(i==3){
		wpx3=msg.linear.x;
		wpy3=msg.linear.y;
		}
		if(i==4){
		wpx4=msg.linear.x;
		wpy4=msg.linear.y;
		}
		if(i==5){
		wpx5=msg.linear.x;
		wpy5=msg.linear.y;
		}
/*
		if(i==6){
		wpx6=msg.linear.x;
		wpy6=msg.linear.y;
		}
		if(i==7){
		wpx7=msg.linear.x;
		wpy7=msg.linear.y;
		}
*/
		/*
		double time_start=(double)ros::Time::now().toSec();
		while ((double)ros::Time::now().toSec()< time_start+1.0) 
		{
		msgOut.linear.x=0;
		msgOut.linear.y=0;
		msgOut.angular.z=0;
		pub_.publish(msgOut);
		}//time loop
		//publand_.publish(msgLand);
		//yaw_con=1;
		*/
				
		i++;
		if(i>5) publand_.publish(msgLand);
		
		}



	/*
	if(i == 2){
	roll_dist = fabs(roll_ref[i] - roll_ref[i-1]);
	roll_error = roll_ref[i] - msg.linear.y;
	//roll_dist = fabs(roll_ref[i] - roll_ref[i-1]);
	//roll_error = roll_ref[i] - msg.linear.y;
	//pit_dist = sqrt(pow(pit_ref[i]-pit_ref[i-1], 2.0) + pow(roll_ref[i]-roll_ref[i-1], 2.0));
	//pit_error = sqrt(pow(msg.linear.x-pit_ref[i], 2.0) + pow(msg.linear.y-roll_ref[i], 2.0));
	msgOut.linear.y = roll_Kp * (roll_error / roll_dist);
	msgOut.linear.x = 0.0;	
	msgOut.linear.z = 0.0;
	msgOut.angular.x =0.0;
	msgOut.angular.y =0.0;
	msgOut.angular.z =0.0;
	//msgOut.linear.y = roll_Kp*roll_error;
	//if(msg.linear.x > (pit_ref[i]-0.05) && msg.linear.x < (pit_ref[i]+0.05)){
	if(msg.linear.y > (roll_ref[i]-0.03) && msg.linear.y < (roll_ref[i]+0.03)){
		if(i==2){
		wpx2=msg.linear.x;
		wpy2=msg.linear.y;
		}
			
		i++;
		}
	}
*/
	
	/*
	if(yaw_con == 1){
	msgOut.linear.x=0.0;
	msgOut.linear.y=0.0;
	yaw_error = (-1)*((yaw_ref - msg.angular.z) / M_PI);
	msgOut.angular.z = yaw_Kp*yaw_error;
	//msgOut.angular.z = -0.3; 
	if(msg.angular.z > (yaw_ref-0.2) && msg.angular.z < (yaw_ref+0.2)){
		double time_start=(double)ros::Time::now().toSec();
		while ((double)ros::Time::now().toSec()< time_start+2.0) 
		{
		msgOut.linear.x=0.0;
		msgOut.linear.y=0.0;
		msgOut.angular.z=0.0;
		pub_.publish(msgOut);
		}
		publand_.publish(msgLand);
	}
	}
	*/
	
			//if(msg.linear.y>(roll_ref[i]-0.05) && msg.linear.y<(roll_ref[i]+0.05)){
				//if(i<(pitch_ref.size()-1)){
				//i++;
					//if((i-1) == yaw_waypoint){
					//yaw_con = 1;
					//}
				//}
			//}
		//}
	//}
	
	//if(yaw_con == 1){
	//pit_error = pitch_ref[i-1] - msg.linear.x;
	//roll_error = roll_ref[i-1] - msg.linear.y;
	//msgOut.linear.x = pit_Kp * pit_error;
	//msgOut.linear.y = roll_Kp*roll_error;
	//msgOut.linear.x = 0.0;
	//msgOut.linear.y = 0.0;
	//yaw_error = (yaw_ref - yaw_degrees)*(-1);
	//msgOut.angular.z = yaw_Kp*yaw_error;
		//if(msg.linear.x > (pitch_ref[i-1]-0.05) && msg.linear.x < (pitch_ref[i-1]+0.05)){
			//if(msg.linear.y>(roll_ref[i-1]-0.05) && msg.linear.y<(roll_ref[i-1]+0.05)){
				//if(yaw_degrees>(yaw_ref-5.0) && yaw_degrees<(yaw_ref+5.0)){
				//yaw_con = 0;
				//drone_rot = true;
				//publand_.publish(msgLand);
				//}
			//}			
		//}
	//}
		
		//}
		/*
		if(pitch_ref[i] < pitch_ref[i-1] && roll_ref[i] <= roll_ref[i-1]) {
			if(msg.pose.position.x < pitch_ref[i] && msg.pose.position.y <= roll_ref[i]){
				if(i<(pitch_ref.size()-1)) i++;
			}
		}
		*/
		//if(pitch_ref[i] > pitch_ref[i-1] && roll_ref[i] < roll_ref[i-1]) {
			//if(msg.linear.x > (pitch_ref[i]-0.05) && msg.linear.x < (pitch_ref[i]+0.05)){
				//if(msg.linear.y>(roll_ref[i]-0.05) && msg.linear.y<(roll_ref[i]+0.05)){
				//waypoint_reached++;
					//if(waypoint_reached == yaw_waypoint[j]){
						//if(yaw_degrees>(yaw_ref[j]-5.0) && yaw_degrees<(yaw_ref[j]+5.0)){
							//if(i<(pitch_ref.size()-1)){
							//i++;
							//}
						//}
					//}
					//else{
						//if(i<(pitch_ref.size()-1)){
							//i++;
						//}
					//}
				//}
			//}
		//}
		/*
		if(pitch_ref[i] < pitch_ref[i-1] && roll_ref[i] >= roll_ref[i-1]) {
			if(msg.pose.position.x < pitch_ref[i] && msg.pose.position.y >= roll_ref[i]){
				if(i<(pitch_ref.size()-1)) i++;
			}
		}
		*/
		
	//}

	//if(waypoint_reached == pitch_ref.size()){
	//publand_.publish(msgLand);
	//}
	
	//publicar
	pub_.publish(msgOut);
	
	ROS_INFO_STREAM("output_pit ="<<msgOut.linear.x); 
	//ROS_INFO_STREAM("output_roll ="<<msgOut.linear.y);
	//ROS_INFO_STREAM("output_yaw ="<<msgOut.angular.z);  
	ROS_INFO_STREAM("pit_reference ="<<pit_ref[i]); 
	//ROS_INFO_STREAM("roll_reference ="<<roll_ref[i]); 
	//ROS_INFO_STREAM("i ="<<i);  
	//ROS_INFO_STREAM("yaw degrees ="<<yaw_degrees); 
	//ROS_INFO_STREAM("drone_rot ="<<drone_rot); 
	ROS_INFO_STREAM("pit error ="<<pit_error); 
	//ROS_INFO_STREAM("pit dist ="<<pit_dist); 
	//ROS_INFO_STREAM("roll error ="<<roll_error); 
	//ROS_INFO_STREAM("roll dist ="<<roll_dist); 
	ROS_INFO_STREAM("wpx1 ="<<wpx1);
	ROS_INFO_STREAM("wpy1 ="<<wpy1); 
	ROS_INFO_STREAM("wpx2 ="<<wpx2); 
	ROS_INFO_STREAM("wpy2 ="<<wpy2); 
	ROS_INFO_STREAM("wpx3 ="<<wpx3); 
	ROS_INFO_STREAM("wpy3 ="<<wpy3); 
	ROS_INFO_STREAM("wpx4 ="<<wpx4); 
	ROS_INFO_STREAM("wpy4 ="<<wpy4); 
	ROS_INFO_STREAM("wpx5 ="<<wpx5); 
	ROS_INFO_STREAM("wpy5 ="<<wpy5);
	ROS_INFO_STREAM("i ="<<i);  
	//ROS_INFO_STREAM("roll_error ="<<roll_error); 
	//ROS_INFO_STREAM("yaw_error ="<<yaw_error); 
	//ROS_INFO_STREAM("yaw_ref ="<<yaw_ref); 
	//ROS_INFO_STREAM("waypoint reached ="<<waypoint_reached); 
	 
	//ROS_INFO_STREAM("output_roll ="<<msgOut.linear.y);
	//ROS_INFO_STREAM("refChange ="<<refChange);
	
	
	
}
	
int main(int argc, char **argv){
  //inicializamos el nodo pid_control 	  
  ros::init(argc, argv, "pid_control");
  pid_control control;
  //llamamos al callback hasta que exista una interrupcion
  ros::spin();
}
