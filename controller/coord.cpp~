#include "ros/ros.h"
//#include "ardrone_autonomy/Navdata.h" 
#include "geometry_msgs/PoseStamped.h" 
#include "geometry_msgs/Twist.h"
#include "LinearMath/btQuaternion.h"
#include "LinearMath/btMatrix3x3.h"

class coord
{

public:	
	coord(){
            pub_ = n_.advertise<geometry_msgs::Twist>("/ORB_SLAM/euler_pose", 1); 

            sub_ = n_.subscribe("/ORB_SLAM/pose", 1, &pid_control::callback, this); 
	}

	void callback(const geometry_msgs::PoseStaped &msg);  
	
	private : 
	ros::NodeHandle n_; 
	ros::Publisher pub_; 
	ros::Subscriber sub_;

};

void pid_control::callback(const geometry_msgs::PoseStamped &msg){
	
	geometry_msgs::Twist msgOut; 

	msgOut.linear.x = msg.pose.position.z;
	msgOut.linear.y = msg.pose.position.x;
	msgOut.linear.z = msg.pose.position.y * (-1);

        float qx = msg.pose.orientation.x;
        float qy = msg.pose.orientation.y;
        float qz = msg.pose.orientation.z;
        float qw = msg.pose.orientation.w;

	btQuaternion q(qx,qy,qz,qw);	
	double roll, pitch, yaw;
	btMatrix3x3(q).getRPY(roll, pitch, yaw);
	
	msgOut.angular.x = roll;
	msgOut.angular.y = pitch;
	msgOut.angular.z = yaw;

	ROS_INFO_STREAM("output_pit ="<<msgOut.linear.x);  
	//ROS_INFO_STREAM("output_roll ="<<msgOut.linear.y);
	//ROS_INFO_STREAM("refChange ="<<refChange);
	
	//publicar
	pub_.publish(msgOut);
	
}
	
int main(int argc, char **argv){
  //inicializamos el nodo pid_control 	  
  ros::init(argc, argv, "coord");
  coord corrpose;
  //llamamos al callback hasta que exista una interrupcion
  ros::spin();
	}
